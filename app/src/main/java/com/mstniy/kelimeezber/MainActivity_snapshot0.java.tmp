package com.mstniy.kelimeezber;

import android.graphics.Color;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Random;

import static java.lang.Math.exp;
import static java.lang.Math.max;
import static java.lang.Math.min;

class Pair
{
    public String first;
    public String second;
    public Pair(String _first, String _second) {
        first = _first;
        second = _second;
    }
};

public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    ArrayList<Integer> uncoveredPairs = new ArrayList<Integer>();
    ArrayList<Pair> wlist = new ArrayList<Pair>();
    ArrayList<Double> hardness = new ArrayList<Double>(); // A hardness score for each pair in wlist
    TextView label;
    Button buttons[] = new Button[4];
    String translations[] = new String[4]; // The translation of the text displayed on each of the buttons. We keep this because different words in one language may correspond to the same words in the other. (if a=c and b=c and we ask the user "c=a or b", she can click to either of them.)
    int currentPairIndex;
    final int MistakeQueueLength=4;
    int mistakeQueue[]={-1,-1,-1,-1};
    int currentQueueIndex=MistakeQueueLength-1; // This doesn't really matter



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        label = findViewById(R.id.label);
        buttons[0] = findViewById(R.id.button0);
        buttons[1] = findViewById(R.id.button1);
        buttons[2] = findViewById(R.id.button2);
        buttons[3] = findViewById(R.id.button3);
        for (int i=0;i<4;i++)
            buttons[i].setOnClickListener(this);
        AddToWordList();
        NewRound();
    }

    /*bool AddToWordList(ifstream& in)
    {
        bool faultyLine=false;
        for (int i=1; ;i++)
        {
            string line;
            getline(in, line);
            if (in.fail())
                break;
            auto pos = line.find("=");

            //regex word_regex("(.+?)\\s*=\\s*(.+)");
            regex word_regex("^([^#]+?)\\s*=\\s*([^#]+?)\\s*(#|$)");
            auto words_begin = std::sregex_iterator(line.begin(), line.end(), word_regex);
            auto words_end = std::sregex_iterator();
            if (words_begin == words_end)
            {
                cout << "Line " << i << " invalid (no match found)" << endl;
                faultyLine=true;
                continue;
            }
            std::smatch match = *words_begin;
            assert(match.size() == 4);
            wlist.push_back(make_pair(match.str(1), match.str(2)));
            uncoveredPairs.push_back(wlist.size()-1);
            hardness.push_back(0);
        }
        return faultyLine==false;
    }*/

    boolean AddToWordList()
    {
        // TODO: To support adding new words, use a db.
        wlist.add(new Pair("sedan", "since"));
        wlist.add(new Pair("annars", "otherwise"));
        wlist.add(new Pair("Ã¤ven om", "even if"));
        wlist.add(new Pair("snygg", "nice"));
        wlist.add(new Pair("trevlig", "nice"));
        uncoveredPairs.add(0);
        uncoveredPairs.add(1);
        uncoveredPairs.add(2);
        uncoveredPairs.add(3);
        uncoveredPairs.add(4);
        hardness.add(0.0);
        hardness.add(0.0);
        hardness.add(0.0);
        hardness.add(0.0);
        hardness.add(0.0);

        return true;
    }

    int GetRandomPairIndex()
    {
        if (uncoveredPairs.size() > 0) // Choose an uncovered pair
        {
            final int uncoveredPairsIndex = new Random().nextInt(uncoveredPairs.size());
            final int index = uncoveredPairs.get(uncoveredPairsIndex);
            //swap(uncoveredPairs[uncoveredPairsIndex], uncoveredPairs[uncoveredPairs.size()-1]);
            final int tmp = uncoveredPairs.get(uncoveredPairsIndex);
            uncoveredPairs.set(uncoveredPairsIndex, uncoveredPairs.get(uncoveredPairs.size()-1));
            uncoveredPairs.set(uncoveredPairs.size()-1, tmp);
            uncoveredPairs.remove(uncoveredPairs.size()-1);
            return index;
        }
        double hardnessSum = 0;
        for (double h : hardness)
            hardnessSum += exp(h);
        if (hardnessSum == 0)
            return 0;
        double rnd = new Random().nextDouble() * hardnessSum;
        for (int i=0; i<hardness.size(); i++)
        {
            if (exp(hardness.get(i))>rnd)
                return i;
            rnd -= exp(hardness.get(i));
        }
        return hardness.size()-1; // Mathematically, this cannot happen. But we're dealing with floats, so who knows.
    }

    void ChangeColorOfButton(Button button, boolean highlight)
    {
        if (highlight)
            button.setBackgroundColor(Color.rgb(100, 255, 100));
        else
            button.setBackgroundResource(android.R.drawable.btn_default);
    }

    void NewRound()
    {
        //cout << (wlist.size()-uncoveredPairs.size()) << "/" << wlist.size() << " pairs covered." << endl;
        for (int i=0;i<4;i++)
            ChangeColorOfButton(buttons[i], false);
        currentQueueIndex=(currentQueueIndex+1)%MistakeQueueLength;
        if (mistakeQueue[currentQueueIndex] != -1)
            currentPairIndex=mistakeQueue[currentQueueIndex];
        else
            currentPairIndex = GetRandomPairIndex();
        mistakeQueue[currentQueueIndex]=-1;
	    final Pair p = wlist.get(currentPairIndex);
	    final int answer=new Random().nextInt(4);
        final boolean currentFwd = new Random().nextBoolean();
        label.setText(currentFwd?p.first:p.second);
        for (int i=0;i<4;i++)
        {
            if (i == answer) {
                buttons[i].setText(currentFwd ? p.second : p.first);
                translations[i] = currentFwd?p.first:p.second;
            }
		    else {
			    final Pair p2 = wlist.get(new Random().nextInt(wlist.size()));
                buttons[i].setText(currentFwd?p2.second:p2.first);
                translations[i] = currentFwd?p2.first:p2.second;
            }
        }
    }

    public void onClick(View view)
    {
        Button button = (Button)view;
	    int buttonId;
	    if (button.getId() == R.id.button0) buttonId = 0;
        else if (button.getId() == R.id.button1) buttonId = 1;
        else if (button.getId() == R.id.button2) buttonId = 2;
        else if (button.getId() == R.id.button3) buttonId = 3;
        else
            return ;
        if (translations[buttonId].equals(label.getText())) // TODO: If a=c and b=c, during the random option creation we choose both the pairs, we have chosen as the pair to be asked a=c, and the user clicks on the button containing the pair b=c, the user will still have clicked on c, but we won't accept it because a!=b.
        {
            //cout << "Correct!" << endl;
		    final double oldScore = hardness.get(currentPairIndex);
            double newScore = oldScore;
            if (mistakeQueue[currentQueueIndex] == -1) // The user chose the correct answer at the first try
                newScore -= 0.33;
            else
                newScore += 1;
            newScore = min(newScore, 2.0);
            newScore = max(newScore, -1.33);
            hardness.set(currentPairIndex, newScore); // Update the score of the current word
            NewRound();
        }
        else
        {
            //cout << "Incorrect!" << endl;
            mistakeQueue[currentQueueIndex]=currentPairIndex;
            for (int i=0;i<4;i++)
                if (translations[i].equals(label.getText()))
                    ChangeColorOfButton(buttons[i], true);
        }
    }
}
